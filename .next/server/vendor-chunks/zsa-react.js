"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zsa-react";
exports.ids = ["vendor-chunks/zsa-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/zsa-react/dist/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/zsa-react/dist/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useServerAction: () => (/* binding */ useServerAction)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ useServerAction auto */ // src/index.ts\n\n// src/optimistic.ts\nvar evaluateOptimisticInput = (fn, oldResult, result)=>{\n    function isFunction(value) {\n        return typeof value === \"function\";\n    }\n    return isFunction(fn) ? fn(oldResult.status === \"empty\" ? result.data : oldResult.result.data) : fn;\n};\n// src/results.ts\nvar calculateResultFromState = (state)=>{\n    const { isPending, oldResult, result } = state;\n    if (isPending && oldResult.status === \"empty\") {\n        return {\n            isPending: true,\n            isOptimistic: false,\n            data: state.persistDataWhilePending ? result.data : void 0,\n            isError: false,\n            error: state.persistErrorWhilePending ? result.error : void 0,\n            isSuccess: false,\n            status: \"pending\"\n        };\n    } else if (isPending && oldResult.status === \"filled\" && result.status === \"success\") {\n        return {\n            isPending: true,\n            isOptimistic: true,\n            data: result.data,\n            isError: false,\n            error: void 0,\n            isSuccess: false,\n            status: \"pending\"\n        };\n    } else if (result.status === \"success\") {\n        return {\n            isPending: false,\n            isOptimistic: false,\n            data: result.data,\n            isError: false,\n            error: void 0,\n            isSuccess: true,\n            status: \"success\"\n        };\n    } else if (result.status === \"error\") {\n        return {\n            isPending: false,\n            data: void 0,\n            isError: true,\n            error: result.error,\n            isOptimistic: false,\n            isSuccess: false,\n            status: \"error\"\n        };\n    } else {\n        return {\n            isPending: false,\n            data: void 0,\n            isOptimistic: false,\n            isError: false,\n            error: void 0,\n            isSuccess: false,\n            status: \"idle\"\n        };\n    }\n};\nvar getEmptyResult = (initialData)=>initialData === void 0 ? // if there is no initial data\n    {\n        status: \"idle\",\n        error: void 0,\n        data: void 0\n    } : {\n        // if there is initial data\n        status: \"success\",\n        error: void 0,\n        data: initialData\n    };\nvar getEmptyOldResult = ()=>({\n        status: \"empty\",\n        result: void 0\n    });\n// src/retries.ts\nvar getRetryDelay = (retryConfig, retryCount, err)=>{\n    const shouldRetry = retryConfig ? retryCount + 1 < retryConfig.maxAttempts : false;\n    let retryDelay = 0;\n    const retryDelayOpt = retryConfig?.delay;\n    if (retryDelayOpt && typeof retryDelayOpt === \"function\") {\n        retryDelay = retryDelayOpt(retryCount + 1, err);\n    } else if (retryDelayOpt && typeof retryDelayOpt === \"number\") {\n        retryDelay = retryDelayOpt;\n    }\n    if (!shouldRetry) return -1;\n    return retryDelay;\n};\n// src/utils.ts\nvar mergePossibleObjects = (obj1, obj2)=>{\n    if (obj1 === void 0 && obj2 === void 0) {\n        return void 0;\n    }\n    if (obj1 === void 0) return obj2;\n    if (obj2 === void 0) return obj1;\n    if (typeof obj1 !== \"object\" || typeof obj2 !== \"object\") {\n        return obj2;\n    }\n    return {\n        ...obj1,\n        ...obj2\n    };\n};\n// src/index.ts\nvar useServerAction = (serverAction, opts)=>{\n    const initialData = opts?.initialData;\n    const bindArgs = opts?.bind;\n    const [result, $setResult] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getEmptyResult(initialData));\n    const resultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(getEmptyResult(initialData));\n    const [oldResult, $setOldResult] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getEmptyOldResult());\n    const oldResultRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(getEmptyOldResult());\n    const lastRetryId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const executeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [isTransitioning, startTransition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useTransition)();\n    const [isExecuting, setExecuting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const status = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"idle\");\n    const setResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[setResult]\": (result2)=>{\n            $setResult(result2);\n            resultRef.current = result2;\n        }\n    }[\"useServerAction.useCallback[setResult]\"], [\n        $setResult\n    ]);\n    const setOldResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[setOldResult]\": (oldResult2)=>{\n            $setOldResult(oldResult2);\n            oldResultRef.current = oldResult2;\n        }\n    }[\"useServerAction.useCallback[setOldResult]\"], [\n        $setOldResult\n    ]);\n    const internalExecute = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[internalExecute]\": async (input, overrideData, args)=>{\n            const { isFromRetryId } = args || {};\n            if (isFromRetryId && lastRetryId.current !== isFromRetryId) {\n                return [\n                    null,\n                    {\n                        message: \"Could not successfully execute the server action\",\n                        data: \"Could not successfully execute the server action\",\n                        stack: \"\",\n                        name: \"ZSAError\",\n                        code: \"ERROR\"\n                    }\n                ];\n            }\n            if (!isFromRetryId) {\n                retryCount.current = 0;\n            }\n            const retryId = Math.floor(Math.random() * 1e4);\n            lastRetryId.current = retryId;\n            if (opts?.onStart) opts.onStart();\n            status.current = \"pending\";\n            setExecuting(true);\n            let data, err;\n            await serverAction(input, overrideData).then({\n                \"useServerAction.useCallback[internalExecute]\": (response)=>{\n                    if (response) {\n                        ;\n                        [data, err] = response;\n                    }\n                }\n            }[\"useServerAction.useCallback[internalExecute]\"]);\n            if (err) {\n                let retryDelay = getRetryDelay(opts?.retry, retryCount.current, err);\n                if (retryDelay >= 0) {\n                    retryCount.current += 1;\n                    return await new Promise({\n                        \"useServerAction.useCallback[internalExecute]\": (resolve)=>setTimeout({\n                                \"useServerAction.useCallback[internalExecute]\": ()=>{\n                                    internalExecute(input, overrideData, {\n                                        ...args || {},\n                                        isFromRetryId: retryId\n                                    }).then(resolve);\n                                }\n                            }[\"useServerAction.useCallback[internalExecute]\"], retryDelay)\n                    }[\"useServerAction.useCallback[internalExecute]\"]);\n                }\n                if (oldResult.status === \"filled\") {\n                    setResult(oldResult.result);\n                } else {\n                    setResult({\n                        error: err,\n                        data: void 0,\n                        status: \"error\"\n                    });\n                }\n                setOldResult({\n                    status: \"empty\",\n                    result: void 0\n                });\n                status.current = \"error\";\n                setExecuting(false);\n                return [\n                    data,\n                    err\n                ];\n            }\n            const res = {\n                error: void 0,\n                data: data ?? void 0,\n                status: \"success\"\n            };\n            setResult(res);\n            setOldResult({\n                status: \"empty\",\n                result: void 0\n            });\n            status.current = \"success\";\n            setExecuting(false);\n            return [\n                data,\n                err\n            ];\n        }\n    }[\"useServerAction.useCallback[internalExecute]\"], [\n        serverAction\n    ]);\n    const execute = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[execute]\": async (...opts2)=>{\n            return await new Promise({\n                \"useServerAction.useCallback[execute]\": (resolve)=>{\n                    executeRef.current = resolve;\n                    startTransition({\n                        \"useServerAction.useCallback[execute]\": ()=>{\n                            internalExecute(opts2[0], mergePossibleObjects(bindArgs, opts2[1]));\n                        }\n                    }[\"useServerAction.useCallback[execute]\"]);\n                }\n            }[\"useServerAction.useCallback[execute]\"]);\n        }\n    }[\"useServerAction.useCallback[execute]\"], [\n        internalExecute\n    ]);\n    const executeFormAction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[executeFormAction]\": async (...opts2)=>{\n            return await new Promise({\n                \"useServerAction.useCallback[executeFormAction]\": (resolve)=>{\n                    startTransition({\n                        \"useServerAction.useCallback[executeFormAction]\": ()=>{\n                            internalExecute(opts2[0], bindArgs);\n                        }\n                    }[\"useServerAction.useCallback[executeFormAction]\"]);\n                    executeRef.current = resolve;\n                    resolve(null);\n                }\n            }[\"useServerAction.useCallback[executeFormAction]\"]);\n        }\n    }[\"useServerAction.useCallback[executeFormAction]\"], [\n        internalExecute\n    ]);\n    const setOptimistic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[setOptimistic]\": async (fn)=>{\n            const data = evaluateOptimisticInput(fn, oldResultRef.current, resultRef.current);\n            if (oldResult.status === \"empty\") {\n                setOldResult({\n                    status: \"filled\",\n                    result: {\n                        ...result\n                    }\n                });\n            }\n            setResult({\n                error: void 0,\n                data: data ?? void 0,\n                status: \"success\"\n            });\n        }\n    }[\"useServerAction.useCallback[setOptimistic]\"], [\n        execute\n    ]);\n    const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[reset]\": ()=>{\n            setResult(getEmptyResult());\n            setOldResult(getEmptyOldResult());\n            setExecuting(false);\n            status.current = \"idle\";\n            lastRetryId.current = 0;\n            retryCount.current = 0;\n        }\n    }[\"useServerAction.useCallback[reset]\"], []);\n    const isRunningCallbacks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const handleCallbacks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useServerAction.useCallback[handleCallbacks]\": ()=>{\n            if (!executeRef.current || isRunningCallbacks.current) {\n                return;\n            }\n            isRunningCallbacks.current = true;\n            if (status.current === \"success\") {\n                executeRef.current?.([\n                    resultRef.current.data,\n                    null\n                ]);\n                opts?.onSuccess?.({\n                    data: resultRef.current.data\n                });\n                opts?.onFinish?.([\n                    resultRef.current.data,\n                    null\n                ]);\n            }\n            if (status.current === \"error\") {\n                executeRef.current?.([\n                    null,\n                    resultRef.current.error\n                ]);\n                opts?.onError?.({\n                    err: resultRef.current.error\n                });\n                opts?.onFinish?.([\n                    null,\n                    resultRef.current.error\n                ]);\n            }\n            executeRef.current = void 0;\n            status.current = \"idle\";\n            isRunningCallbacks.current = false;\n        }\n    }[\"useServerAction.useCallback[handleCallbacks]\"], [\n        opts?.onError,\n        opts?.onFinish,\n        opts?.onSuccess\n    ]);\n    const isPending = isTransitioning || isExecuting;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useServerAction.useEffect\": ()=>{\n            if (isPending) return;\n            handleCallbacks();\n        }\n    }[\"useServerAction.useEffect\"], [\n        status.current,\n        isPending\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useServerAction.useEffect\": ()=>{\n            return ({\n                \"useServerAction.useEffect\": ()=>{\n                    if (executeRef.current !== void 0) {\n                        handleCallbacks();\n                    }\n                }\n            })[\"useServerAction.useEffect\"];\n        }\n    }[\"useServerAction.useEffect\"], []);\n    const final = calculateResultFromState({\n        isPending,\n        oldResult,\n        result: resultRef.current,\n        persistDataWhilePending: opts?.persistDataWhilePending,\n        persistErrorWhilePending: opts?.persistErrorWhilePending\n    });\n    return {\n        ...final,\n        reset,\n        execute,\n        setOptimistic,\n        executeFormAction\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvenNhLXJlYWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O3FFQUVBLGVBQWU7QUFDaUU7QUFFaEYsb0JBQW9CO0FBQ3BCLElBQUlLLDBCQUEwQixDQUFDQyxJQUFJQyxXQUFXQztJQUM1QyxTQUFTQyxXQUFXQyxLQUFLO1FBQ3ZCLE9BQU8sT0FBT0EsVUFBVTtJQUMxQjtJQUNBLE9BQU9ELFdBQVdILE1BQU1BLEdBQUdDLFVBQVVJLE1BQU0sS0FBSyxVQUFVSCxPQUFPSSxJQUFJLEdBQUdMLFVBQVVDLE1BQU0sQ0FBQ0ksSUFBSSxJQUFJTjtBQUNuRztBQUVBLGlCQUFpQjtBQUNqQixJQUFJTywyQkFBMkIsQ0FBQ0M7SUFDOUIsTUFBTSxFQUFFQyxTQUFTLEVBQUVSLFNBQVMsRUFBRUMsTUFBTSxFQUFFLEdBQUdNO0lBQ3pDLElBQUlDLGFBQWFSLFVBQVVJLE1BQU0sS0FBSyxTQUFTO1FBQzdDLE9BQU87WUFDTEksV0FBVztZQUNYQyxjQUFjO1lBQ2RKLE1BQU1FLE1BQU1HLHVCQUF1QixHQUFHVCxPQUFPSSxJQUFJLEdBQUcsS0FBSztZQUN6RE0sU0FBUztZQUNUQyxPQUFPTCxNQUFNTSx3QkFBd0IsR0FBR1osT0FBT1csS0FBSyxHQUFHLEtBQUs7WUFDNURFLFdBQVc7WUFDWFYsUUFBUTtRQUNWO0lBQ0YsT0FBTyxJQUFJSSxhQUFhUixVQUFVSSxNQUFNLEtBQUssWUFBWUgsT0FBT0csTUFBTSxLQUFLLFdBQVc7UUFDcEYsT0FBTztZQUNMSSxXQUFXO1lBQ1hDLGNBQWM7WUFDZEosTUFBTUosT0FBT0ksSUFBSTtZQUNqQk0sU0FBUztZQUNUQyxPQUFPLEtBQUs7WUFDWkUsV0FBVztZQUNYVixRQUFRO1FBQ1Y7SUFDRixPQUFPLElBQUlILE9BQU9HLE1BQU0sS0FBSyxXQUFXO1FBQ3RDLE9BQU87WUFDTEksV0FBVztZQUNYQyxjQUFjO1lBQ2RKLE1BQU1KLE9BQU9JLElBQUk7WUFDakJNLFNBQVM7WUFDVEMs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TyxLQUFLLFNBQVM7Z0JBQzlCUCxXQUFXTyxPQUFPLEdBQUc7b0JBQUM7b0JBQU1YLFVBQVVXLE9BQU8sQ0FBQ25DLEtBQUs7aUJBQUM7Z0JBQ3BEb0IsTUFBTWdELFVBQVU7b0JBQ2QzRCxLQUFLZSxVQUFVVyxPQUFPLENBQUNuQyxLQUFLO2dCQUM5QjtnQkFDQW9CLE1BQU0rQyxXQUFXO29CQUFDO29CQUFNM0MsVUFBVVcsT0FBTyxDQUFDbkMsS0FBSztpQkFBQztZQUNsRDtZQUNBNEIsV0FBV08sT0FBTyxHQUFHLEtBQUs7WUFDMUIzQyxPQUFPMkMsT0FBTyxHQUFHO1lBQ2pCNkIsbUJBQW1CN0IsT0FBTyxHQUFHO1FBQy9CO3VEQUFHO1FBQUNmLE1BQU1nRDtRQUFTaEQsTUFBTStDO1FBQVUvQyxNQUFNOEM7S0FBVTtJQUNuRCxNQUFNdEUsWUFBWWlDLG1CQUFtQkU7SUFDckNqRCxnREFBU0E7cUNBQUM7WUFDUixJQUFJYyxXQUNGO1lBQ0ZxRTtRQUNGO29DQUFHO1FBQUN6RSxPQUFPMkMsT0FBTztRQUFFdkM7S0FBVTtJQUM5QmQsZ0RBQVNBO3FDQUFDO1lBQ1I7NkNBQU87b0JBQ0wsSUFBSThDLFdBQVdPLE9BQU8sS0FBSyxLQUFLLEdBQUc7d0JBQ2pDOEI7b0JBQ0Y7Z0JBQ0Y7O1FBQ0Y7b0NBQUcsRUFBRTtJQUNMLE1BQU1JLFFBQVEzRSx5QkFBeUI7UUFDckNFO1FBQ0FSO1FBQ0FDLFFBQVFtQyxVQUFVVyxPQUFPO1FBQ3pCckMseUJBQXlCc0IsTUFBTXRCO1FBQy9CRywwQkFBMEJtQixNQUFNbkI7SUFDbEM7SUFDQSxPQUFPO1FBQ0wsR0FBR29FLEtBQUs7UUFDUk47UUFDQUo7UUFDQUc7UUFDQUQ7SUFDRjtBQUNGO0FBR0UiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcemFpbnVsYWFiYWlkaW5cXERvd25sb2Fkc1xcRmluYWxQcm9qZWN0LW1haW5cXEZpbmFsUHJvamVjdC1tYWluXFxub2RlX21vZHVsZXNcXHpzYS1yZWFjdFxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZVRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL29wdGltaXN0aWMudHNcbnZhciBldmFsdWF0ZU9wdGltaXN0aWNJbnB1dCA9IChmbiwgb2xkUmVzdWx0LCByZXN1bHQpID0+IHtcbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuICByZXR1cm4gaXNGdW5jdGlvbihmbikgPyBmbihvbGRSZXN1bHQuc3RhdHVzID09PSBcImVtcHR5XCIgPyByZXN1bHQuZGF0YSA6IG9sZFJlc3VsdC5yZXN1bHQuZGF0YSkgOiBmbjtcbn07XG5cbi8vIHNyYy9yZXN1bHRzLnRzXG52YXIgY2FsY3VsYXRlUmVzdWx0RnJvbVN0YXRlID0gKHN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgaXNQZW5kaW5nLCBvbGRSZXN1bHQsIHJlc3VsdCB9ID0gc3RhdGU7XG4gIGlmIChpc1BlbmRpbmcgJiYgb2xkUmVzdWx0LnN0YXR1cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUGVuZGluZzogdHJ1ZSxcbiAgICAgIGlzT3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICBkYXRhOiBzdGF0ZS5wZXJzaXN0RGF0YVdoaWxlUGVuZGluZyA/IHJlc3VsdC5kYXRhIDogdm9pZCAwLFxuICAgICAgaXNFcnJvcjogZmFsc2UsXG4gICAgICBlcnJvcjogc3RhdGUucGVyc2lzdEVycm9yV2hpbGVQZW5kaW5nID8gcmVzdWx0LmVycm9yIDogdm9pZCAwLFxuICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzUGVuZGluZyAmJiBvbGRSZXN1bHQuc3RhdHVzID09PSBcImZpbGxlZFwiICYmIHJlc3VsdC5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUGVuZGluZzogdHJ1ZSxcbiAgICAgIGlzT3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgaXNFcnJvcjogZmFsc2UsXG4gICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUGVuZGluZzogZmFsc2UsXG4gICAgICBpc09wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICBpc0Vycm9yOiBmYWxzZSxcbiAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICBpc1N1Y2Nlc3M6IHRydWUsXG4gICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiXG4gICAgfTtcbiAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNQZW5kaW5nOiBmYWxzZSxcbiAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgaXNPcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgIGlzU3VjY2VzczogZmFsc2UsXG4gICAgICBzdGF0dXM6IFwiZXJyb3JcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzUGVuZGluZzogZmFsc2UsXG4gICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICBpc09wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgaXNFcnJvcjogZmFsc2UsXG4gICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgIHN0YXR1czogXCJpZGxlXCJcbiAgICB9O1xuICB9XG59O1xudmFyIGdldEVtcHR5UmVzdWx0ID0gKGluaXRpYWxEYXRhKSA9PiBpbml0aWFsRGF0YSA9PT0gdm9pZCAwID8gKFxuICAvLyBpZiB0aGVyZSBpcyBubyBpbml0aWFsIGRhdGFcbiAge1xuICAgIHN0YXR1czogXCJpZGxlXCIsXG4gICAgZXJyb3I6IHZvaWQgMCxcbiAgICBkYXRhOiB2b2lkIDBcbiAgfVxuKSA6IHtcbiAgLy8gaWYgdGhlcmUgaXMgaW5pdGlhbCBkYXRhXG4gIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gIGVycm9yOiB2b2lkIDAsXG4gIGRhdGE6IGluaXRpYWxEYXRhXG59O1xudmFyIGdldEVtcHR5T2xkUmVzdWx0ID0gKCkgPT4gKHtcbiAgc3RhdHVzOiBcImVtcHR5XCIsXG4gIHJlc3VsdDogdm9pZCAwXG59KTtcblxuLy8gc3JjL3JldHJpZXMudHNcbnZhciBnZXRSZXRyeURlbGF5ID0gKHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBlcnIpID0+IHtcbiAgY29uc3Qgc2hvdWxkUmV0cnkgPSByZXRyeUNvbmZpZyA/IHJldHJ5Q291bnQgKyAxIDwgcmV0cnlDb25maWcubWF4QXR0ZW1wdHMgOiBmYWxzZTtcbiAgbGV0IHJldHJ5RGVsYXkgPSAwO1xuICBjb25zdCByZXRyeURlbGF5T3B0ID0gcmV0cnlDb25maWc/LmRlbGF5O1xuICBpZiAocmV0cnlEZWxheU9wdCAmJiB0eXBlb2YgcmV0cnlEZWxheU9wdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0cnlEZWxheSA9IHJldHJ5RGVsYXlPcHQocmV0cnlDb3VudCArIDEsIGVycik7XG4gIH0gZWxzZSBpZiAocmV0cnlEZWxheU9wdCAmJiB0eXBlb2YgcmV0cnlEZWxheU9wdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHJ5RGVsYXkgPSByZXRyeURlbGF5T3B0O1xuICB9XG4gIGlmICghc2hvdWxkUmV0cnkpXG4gICAgcmV0dXJuIC0xO1xuICByZXR1cm4gcmV0cnlEZWxheTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIG1lcmdlUG9zc2libGVPYmplY3RzID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IHZvaWQgMCAmJiBvYmoyID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChvYmoxID09PSB2b2lkIDApXG4gICAgcmV0dXJuIG9iajI7XG4gIGlmIChvYmoyID09PSB2b2lkIDApXG4gICAgcmV0dXJuIG9iajE7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqMiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBvYmoyO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ub2JqMSxcbiAgICAuLi5vYmoyXG4gIH07XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciB1c2VTZXJ2ZXJBY3Rpb24gPSAoc2VydmVyQWN0aW9uLCBvcHRzKSA9PiB7XG4gIGNvbnN0IGluaXRpYWxEYXRhID0gb3B0cz8uaW5pdGlhbERhdGE7XG4gIGNvbnN0IGJpbmRBcmdzID0gb3B0cz8uYmluZDtcbiAgY29uc3QgW3Jlc3VsdCwgJHNldFJlc3VsdF0gPSB1c2VTdGF0ZShcbiAgICBnZXRFbXB0eVJlc3VsdChpbml0aWFsRGF0YSlcbiAgKTtcbiAgY29uc3QgcmVzdWx0UmVmID0gdXNlUmVmKFxuICAgIGdldEVtcHR5UmVzdWx0KGluaXRpYWxEYXRhKVxuICApO1xuICBjb25zdCBbb2xkUmVzdWx0LCAkc2V0T2xkUmVzdWx0XSA9IHVzZVN0YXRlKGdldEVtcHR5T2xkUmVzdWx0KCkpO1xuICBjb25zdCBvbGRSZXN1bHRSZWYgPSB1c2VSZWYoZ2V0RW1wdHlPbGRSZXN1bHQoKSk7XG4gIGNvbnN0IGxhc3RSZXRyeUlkID0gdXNlUmVmKDApO1xuICBjb25zdCByZXRyeUNvdW50ID0gdXNlUmVmKDApO1xuICBjb25zdCBleGVjdXRlUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IFtpc1RyYW5zaXRpb25pbmcsIHN0YXJ0VHJhbnNpdGlvbl0gPSB1c2VUcmFuc2l0aW9uKCk7XG4gIGNvbnN0IFtpc0V4ZWN1dGluZywgc2V0RXhlY3V0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgc3RhdHVzID0gdXNlUmVmKFwiaWRsZVwiKTtcbiAgY29uc3Qgc2V0UmVzdWx0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHJlc3VsdDIpID0+IHtcbiAgICAgICRzZXRSZXN1bHQocmVzdWx0Mik7XG4gICAgICByZXN1bHRSZWYuY3VycmVudCA9IHJlc3VsdDI7XG4gICAgfSxcbiAgICBbJHNldFJlc3VsdF1cbiAgKTtcbiAgY29uc3Qgc2V0T2xkUmVzdWx0ID0gdXNlQ2FsbGJhY2soXG4gICAgKG9sZFJlc3VsdDIpID0+IHtcbiAgICAgICRzZXRPbGRSZXN1bHQob2xkUmVzdWx0Mik7XG4gICAgICBvbGRSZXN1bHRSZWYuY3VycmVudCA9IG9sZFJlc3VsdDI7XG4gICAgfSxcbiAgICBbJHNldE9sZFJlc3VsdF1cbiAgKTtcbiAgY29uc3QgaW50ZXJuYWxFeGVjdXRlID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGlucHV0LCBvdmVycmlkZURhdGEsIGFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHsgaXNGcm9tUmV0cnlJZCB9ID0gYXJncyB8fCB7fTtcbiAgICAgIGlmIChpc0Zyb21SZXRyeUlkICYmIGxhc3RSZXRyeUlkLmN1cnJlbnQgIT09IGlzRnJvbVJldHJ5SWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IHN1Y2Nlc3NmdWxseSBleGVjdXRlIHRoZSBzZXJ2ZXIgYWN0aW9uXCIsXG4gICAgICAgICAgICBkYXRhOiBcIkNvdWxkIG5vdCBzdWNjZXNzZnVsbHkgZXhlY3V0ZSB0aGUgc2VydmVyIGFjdGlvblwiLFxuICAgICAgICAgICAgc3RhY2s6IFwiXCIsXG4gICAgICAgICAgICBuYW1lOiBcIlpTQUVycm9yXCIsXG4gICAgICAgICAgICBjb2RlOiBcIkVSUk9SXCJcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnJvbVJldHJ5SWQpIHtcbiAgICAgICAgcmV0cnlDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHJ5SWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTQpO1xuICAgICAgbGFzdFJldHJ5SWQuY3VycmVudCA9IHJldHJ5SWQ7XG4gICAgICBpZiAob3B0cz8ub25TdGFydClcbiAgICAgICAgb3B0cy5vblN0YXJ0KCk7XG4gICAgICBzdGF0dXMuY3VycmVudCA9IFwicGVuZGluZ1wiO1xuICAgICAgc2V0RXhlY3V0aW5nKHRydWUpO1xuICAgICAgbGV0IGRhdGEsIGVycjtcbiAgICAgIGF3YWl0IHNlcnZlckFjdGlvbihpbnB1dCwgb3ZlcnJpZGVEYXRhKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgW2RhdGEsIGVycl0gPSByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxldCByZXRyeURlbGF5ID0gZ2V0UmV0cnlEZWxheShvcHRzPy5yZXRyeSwgcmV0cnlDb3VudC5jdXJyZW50LCBlcnIpO1xuICAgICAgICBpZiAocmV0cnlEZWxheSA+PSAwKSB7XG4gICAgICAgICAgcmV0cnlDb3VudC5jdXJyZW50ICs9IDE7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpbnRlcm5hbEV4ZWN1dGUoaW5wdXQsIG92ZXJyaWRlRGF0YSwge1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MgfHwge30sXG4gICAgICAgICAgICAgICAgaXNGcm9tUmV0cnlJZDogcmV0cnlJZFxuICAgICAgICAgICAgICB9KS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSwgcmV0cnlEZWxheSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRSZXN1bHQuc3RhdHVzID09PSBcImZpbGxlZFwiKSB7XG4gICAgICAgICAgc2V0UmVzdWx0KG9sZFJlc3VsdC5yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFJlc3VsdCh7XG4gICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPbGRSZXN1bHQoe1xuICAgICAgICAgIHN0YXR1czogXCJlbXB0eVwiLFxuICAgICAgICAgIHJlc3VsdDogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuY3VycmVudCA9IFwiZXJyb3JcIjtcbiAgICAgICAgc2V0RXhlY3V0aW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFtkYXRhLCBlcnJdO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICBkYXRhOiBkYXRhID8/IHZvaWQgMCxcbiAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIlxuICAgICAgfTtcbiAgICAgIHNldFJlc3VsdChyZXMpO1xuICAgICAgc2V0T2xkUmVzdWx0KHtcbiAgICAgICAgc3RhdHVzOiBcImVtcHR5XCIsXG4gICAgICAgIHJlc3VsdDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIHN0YXR1cy5jdXJyZW50ID0gXCJzdWNjZXNzXCI7XG4gICAgICBzZXRFeGVjdXRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIFtkYXRhLCBlcnJdO1xuICAgIH0sXG4gICAgW3NlcnZlckFjdGlvbl1cbiAgKTtcbiAgY29uc3QgZXhlY3V0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICguLi5vcHRzMikgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGV4ZWN1dGVSZWYuY3VycmVudCA9IHJlc29sdmU7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaW50ZXJuYWxFeGVjdXRlKG9wdHMyWzBdLCBtZXJnZVBvc3NpYmxlT2JqZWN0cyhiaW5kQXJncywgb3B0czJbMV0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtpbnRlcm5hbEV4ZWN1dGVdXG4gICk7XG4gIGNvbnN0IGV4ZWN1dGVGb3JtQWN0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKC4uLm9wdHMyKSA9PiB7XG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpbnRlcm5hbEV4ZWN1dGUob3B0czJbMF0sIGJpbmRBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4ZWN1dGVSZWYuY3VycmVudCA9IHJlc29sdmU7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtpbnRlcm5hbEV4ZWN1dGVdXG4gICk7XG4gIGNvbnN0IHNldE9wdGltaXN0aWMgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoZm4pID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldmFsdWF0ZU9wdGltaXN0aWNJbnB1dChcbiAgICAgICAgZm4sXG4gICAgICAgIG9sZFJlc3VsdFJlZi5jdXJyZW50LFxuICAgICAgICByZXN1bHRSZWYuY3VycmVudFxuICAgICAgKTtcbiAgICAgIGlmIChvbGRSZXN1bHQuc3RhdHVzID09PSBcImVtcHR5XCIpIHtcbiAgICAgICAgc2V0T2xkUmVzdWx0KHtcbiAgICAgICAgICBzdGF0dXM6IFwiZmlsbGVkXCIsXG4gICAgICAgICAgcmVzdWx0OiB7IC4uLnJlc3VsdCB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2V0UmVzdWx0KHtcbiAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgZGF0YTogZGF0YSA/PyB2b2lkIDAsXG4gICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2V4ZWN1dGVdXG4gICk7XG4gIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFJlc3VsdChnZXRFbXB0eVJlc3VsdCgpKTtcbiAgICBzZXRPbGRSZXN1bHQoZ2V0RW1wdHlPbGRSZXN1bHQoKSk7XG4gICAgc2V0RXhlY3V0aW5nKGZhbHNlKTtcbiAgICBzdGF0dXMuY3VycmVudCA9IFwiaWRsZVwiO1xuICAgIGxhc3RSZXRyeUlkLmN1cnJlbnQgPSAwO1xuICAgIHJldHJ5Q291bnQuY3VycmVudCA9IDA7XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNSdW5uaW5nQ2FsbGJhY2tzID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaGFuZGxlQ2FsbGJhY2tzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghZXhlY3V0ZVJlZi5jdXJyZW50IHx8IGlzUnVubmluZ0NhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUnVubmluZ0NhbGxiYWNrcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpZiAoc3RhdHVzLmN1cnJlbnQgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBleGVjdXRlUmVmLmN1cnJlbnQ/LihbcmVzdWx0UmVmLmN1cnJlbnQuZGF0YSwgbnVsbF0pO1xuICAgICAgb3B0cz8ub25TdWNjZXNzPy4oe1xuICAgICAgICBkYXRhOiByZXN1bHRSZWYuY3VycmVudC5kYXRhXG4gICAgICB9KTtcbiAgICAgIG9wdHM/Lm9uRmluaXNoPy4oW3Jlc3VsdFJlZi5jdXJyZW50LmRhdGEsIG51bGxdKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cy5jdXJyZW50ID09PSBcImVycm9yXCIpIHtcbiAgICAgIGV4ZWN1dGVSZWYuY3VycmVudD8uKFtudWxsLCByZXN1bHRSZWYuY3VycmVudC5lcnJvcl0pO1xuICAgICAgb3B0cz8ub25FcnJvcj8uKHtcbiAgICAgICAgZXJyOiByZXN1bHRSZWYuY3VycmVudC5lcnJvclxuICAgICAgfSk7XG4gICAgICBvcHRzPy5vbkZpbmlzaD8uKFtudWxsLCByZXN1bHRSZWYuY3VycmVudC5lcnJvcl0pO1xuICAgIH1cbiAgICBleGVjdXRlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgc3RhdHVzLmN1cnJlbnQgPSBcImlkbGVcIjtcbiAgICBpc1J1bm5pbmdDYWxsYmFja3MuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbb3B0cz8ub25FcnJvciwgb3B0cz8ub25GaW5pc2gsIG9wdHM/Lm9uU3VjY2Vzc10pO1xuICBjb25zdCBpc1BlbmRpbmcgPSBpc1RyYW5zaXRpb25pbmcgfHwgaXNFeGVjdXRpbmc7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzUGVuZGluZylcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVDYWxsYmFja3MoKTtcbiAgfSwgW3N0YXR1cy5jdXJyZW50LCBpc1BlbmRpbmddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGV4ZWN1dGVSZWYuY3VycmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGhhbmRsZUNhbGxiYWNrcygpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgZmluYWwgPSBjYWxjdWxhdGVSZXN1bHRGcm9tU3RhdGUoe1xuICAgIGlzUGVuZGluZyxcbiAgICBvbGRSZXN1bHQsXG4gICAgcmVzdWx0OiByZXN1bHRSZWYuY3VycmVudCxcbiAgICBwZXJzaXN0RGF0YVdoaWxlUGVuZGluZzogb3B0cz8ucGVyc2lzdERhdGFXaGlsZVBlbmRpbmcsXG4gICAgcGVyc2lzdEVycm9yV2hpbGVQZW5kaW5nOiBvcHRzPy5wZXJzaXN0RXJyb3JXaGlsZVBlbmRpbmdcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZmluYWwsXG4gICAgcmVzZXQsXG4gICAgZXhlY3V0ZSxcbiAgICBzZXRPcHRpbWlzdGljLFxuICAgIGV4ZWN1dGVGb3JtQWN0aW9uXG4gIH07XG59O1xuZXhwb3J0IHtcbiAgdXNlU2VydmVyQWN0aW9uXG59O1xuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VUcmFuc2l0aW9uIiwiZXZhbHVhdGVPcHRpbWlzdGljSW5wdXQiLCJmbiIsIm9sZFJlc3VsdCIsInJlc3VsdCIsImlzRnVuY3Rpb24iLCJ2YWx1ZSIsInN0YXR1cyIsImRhdGEiLCJjYWxjdWxhdGVSZXN1bHRGcm9tU3RhdGUiLCJzdGF0ZSIsImlzUGVuZGluZyIsImlzT3B0aW1pc3RpYyIsInBlcnNpc3REYXRhV2hpbGVQZW5kaW5nIiwiaXNFcnJvciIsImVycm9yIiwicGVyc2lzdEVycm9yV2hpbGVQZW5kaW5nIiwiaXNTdWNjZXNzIiwiZ2V0RW1wdHlSZXN1bHQiLCJpbml0aWFsRGF0YSIsImdldEVtcHR5T2xkUmVzdWx0IiwiZ2V0UmV0cnlEZWxheSIsInJldHJ5Q29uZmlnIiwicmV0cnlDb3VudCIsImVyciIsInNob3VsZFJldHJ5IiwibWF4QXR0ZW1wdHMiLCJyZXRyeURlbGF5IiwicmV0cnlEZWxheU9wdCIsImRlbGF5IiwibWVyZ2VQb3NzaWJsZU9iamVjdHMiLCJvYmoxIiwib2JqMiIsInVzZVNlcnZlckFjdGlvbiIsInNlcnZlckFjdGlvbiIsIm9wdHMiLCJiaW5kQXJncyIsImJpbmQiLCIkc2V0UmVzdWx0IiwicmVzdWx0UmVmIiwiJHNldE9sZFJlc3VsdCIsIm9sZFJlc3VsdFJlZiIsImxhc3RSZXRyeUlkIiwiZXhlY3V0ZVJlZiIsImlzVHJhbnNpdGlvbmluZyIsInN0YXJ0VHJhbnNpdGlvbiIsImlzRXhlY3V0aW5nIiwic2V0RXhlY3V0aW5nIiwic2V0UmVzdWx0IiwicmVzdWx0MiIsImN1cnJlbnQiLCJzZXRPbGRSZXN1bHQiLCJvbGRSZXN1bHQyIiwiaW50ZXJuYWxFeGVjdXRlIiwiaW5wdXQiLCJvdmVycmlkZURhdGEiLCJhcmdzIiwiaXNGcm9tUmV0cnlJZCIsIm1lc3NhZ2UiLCJzdGFjayIsIm5hbWUiLCJjb2RlIiwicmV0cnlJZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm9uU3RhcnQiLCJ0aGVuIiwicmVzcG9uc2UiLCJyZXRyeSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInJlcyIsImV4ZWN1dGUiLCJvcHRzMiIsImV4ZWN1dGVGb3JtQWN0aW9uIiwic2V0T3B0aW1pc3RpYyIsInJlc2V0IiwiaXNSdW5uaW5nQ2FsbGJhY2tzIiwiaGFuZGxlQ2FsbGJhY2tzIiwib25TdWNjZXNzIiwib25GaW5pc2giLCJvbkVycm9yIiwiZmluYWwiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zsa-react/dist/index.mjs\n");

/***/ })

};
;